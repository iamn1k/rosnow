<!DOCTYPE html>
<html lang="en">
<head>
    <title>Krasnoyarsk Krai 3D Terrain with Model</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.min.js" type="text/javascript"></script>
    <link href="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            z-index: 1;
        }
        .marker {
            background-color: red;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        #toggle2D {
            position: absolute;
            top: 10.8%;
            z-index: 2;
            margin-left: 97.7%;
            background-color: #ffffff;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        #toggleCameraFollow {
            position: absolute;
            top: 15.8%;
            z-index: 2;
            margin-left: 90.7%;
            background-color: #ffffff;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        #interactivePointContainer {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            z-index: 3;
        }
    </style>
</head>
<body>
<button id="toggle2D" style="display: block; margin-top: 10px;">2D</button>
<button id="toggleCameraFollow" style="display: block; margin-top: 10px;">Следовать за самолетом</button>
<div id="controls">
    <h3>Введите координаты</h3>
    <input type="text" id="lat" placeholder="Широта">
    <input type="text" id="lng" placeholder="Долгота">
    <input type="text" id="alt" placeholder="Высота">
    <button id="addPoint">Добавить точку</button>

    <h3>Интерактивное добавление точек</h3>
    <button id="addInteractivePointBtn">Добавить точку интерактивно</button>
    <h3>Управление полетом</h3>
    <button id="drawPath">Построить путь</button>
    <button id="startFlight" style="display:none;">Начать полет</button>
    
    <h3>Время действия сигнала (sec)</h3>
    <div id="timer">0</div> <!-- Секундомер -->
    <div id="flightTime">Общее время полета: 0.00</div> <!-- Общее время полета -->
    <div id="signalPercentage">Процент времени в сигнале: 0%</div> <!-- Процент времени в сигнале -->

    <div id="signalInfo">
        <div id="signalStrength">Уровень сигнала: -120 дБ</div>
        <div id="noiseLevel">Уровень шума: 0 дБ</div>
    </div>

    <!-- Контейнер для ввода высоты -->
    <div id="interactivePointContainer">
        <label for="pointAlt">Введите высоту:</label>
        <input type="text" id="pointAlt" placeholder="Высота в метрах">
        <button id="addInteractivePoint">Добавить точку</button>
        <button id="cancelInteractivePoint">Отменить</button>
    </div>
</div>
<div id="map"></div>

<script type="module">
    const krasnoyarskBounds = [
        [90.0, 53.0], // Southwest coordinates [lng, lat]
        [96.0, 60.0]  // Northeast coordinates [lng, lat]
    ];

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 6,
        center: [92.857, 56.015], // Center coordinates for Krasnoyarsk Krai
        pitch: 70,
        bearing: 0,
        antialias: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'], // https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                terrainSource: {
                    type: 'raster-dem',
                    tiles: [
                        'https://tiles.wifidb.net/data/jaxa_terrainrgb/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1.5
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85,
        maxBounds: krasnoyarskBounds // Restrict map to Krasnoyarsk Krai
    });

    map.addControl(new maplibregl.NavigationControl({
        visualizePitch: true,
        showZoom: true,
        showCompass: true
    }));
    
    document.getElementById('toggle2D').addEventListener('click', () => {
        const currentPitch = map.getPitch();
    
        if (currentPitch > 0) {
            // Переключаем на 2D (вид сверху)
            map.setPitch(0);  // Убираем наклон
            map.setBearing(0);  // Убираем вращение
            map.setZoom(6);  // Устанавливаем обычный масштаб
            document.getElementById('toggle2D').textContent = '3D';
        } else {
            // Переключаем на 3D
            map.setPitch(70);  // Устанавливаем наклон для 3D
            map.setBearing(0);  // Устанавливаем нормальное направление
            map.setZoom(6);  // Масштаб для 3D
            document.getElementById('toggle2D').textContent = '2D';
        }
    });

    const tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    );
    window.tb = tb;
    const points = [];  // Массив для хранения точек маршрута
    let planeModel = null;  // Модель самолета
    let currentPointIndex = 0;  // Индекс текущей точки маршрута
    let interactiveMode = false; // Флаг для интерактивного режима

    // Переключение на интерактивный режим добавления точки
    document.getElementById('addInteractivePointBtn').addEventListener('click', () => {
        interactiveMode = !interactiveMode;
        if (interactiveMode) {
            document.getElementById('interactivePointContainer').style.display = 'block';
            alert("Нажмите на карту, чтобы добавить точку.");
        } else {
            document.getElementById('interactivePointContainer').style.display = 'none';
        }
    });

    // Отменить добавление точки
    document.getElementById('cancelInteractivePoint').addEventListener('click', () => {
        interactiveMode = false;
        document.getElementById('interactivePointContainer').style.display = 'none';
    });

    // Добавление точки при клике на карту
    map.on('click', (e) => {
        if (interactiveMode) {
            const lat = e.lngLat.lat;
            const lng = e.lngLat.lng;

            // Отобразить форму для ввода высоты
            document.getElementById('interactivePointContainer').style.display = 'block';
            document.getElementById('pointAlt').focus();

            // Сохранить координаты точки
            document.getElementById('addInteractivePoint').onclick = () => {
                const alt = parseFloat(document.getElementById('pointAlt').value);
                if (!isNaN(alt)) {
                    points.push({ lat, lng, alt });
                    alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

                    const marker = new maplibregl.Marker()
                        .setLngLat([lng, lat])
                        .setPopup(new maplibregl.Popup().setText('Точка маршрута'))
                        .addTo(map);
                } else {
                    alert("Пожалуйста, введите валидную высоту.");
                }
                document.getElementById('interactivePointContainer').style.display = 'none';
                interactiveMode = false;
            };
        }
    });

    // Добавить точку по координатам
    document.getElementById('addPoint').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('lat').value);
        const lng = parseFloat(document.getElementById('lng').value);
        const alt = parseFloat(document.getElementById('alt').value);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(alt)) {
            points.push({ lat, lng, alt });
            alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

            const marker = new maplibregl.Marker()
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setText('Точка маршрута'))
                .addTo(map);
        } else {
            alert("Пожалуйста, введите валидные координаты.");
        }
    });
    

    function loadTowerModel(lat, lng, alt) {
        const towerModelUrl = 'http://localhost:9000/tower.glb'; // Укажите правильный путь к вашему файлу GLB
        const options = {
            obj: towerModelUrl,
            type: 'gltf',
            scale: 1000,
            units: 'meters',
            rotation: { x: 90, y: 0, z: 0 },
            anchor: 'center'
        };
    
        window.tb.loadObj(options, function (model) {
            model.setCoords([lng, lat, alt]); // Устанавливаем координаты с высотой рельефа
            window.tb.add(model);
            window.tb.update();
            console.log("Model loaded at height:", alt);
        });
    }
    
    

    // Изменение проверки на пересечение с полусферой (исправленный радиус)
    function createSignalDome(lat, lng, height, radius) {
        // Создаем полусферу с помощью Threebox
        const dome = window.tb.sphere({
            color: 'blue',  // Зеленый цвет
            material: 'MeshBasicMaterial', // Простой материал
            transparent: true,  // Сделать полусферу прозрачной
            opacity: 0.3,  // Устанавливаем прозрачность
            side: THREE.DoubleSide, // Покажем обе стороны
            radius: radius,
            units: 'meter',
            phiLength: Math.PI,  // Ограничиваем угол phi до 180 градусов (полусфера)
            anchor: 'center',  // Центрируем сферу по координатам
            adjustment: { x: 0, y: 0, z: -0.5 }  // Сдвиг на 0, чтобы центр совпал с координатами
        })
        .setCoords([lng, lat, height + radius]);  // Устанавливаем координаты
        window.tb.add(dome);
        window.tb.update();
        console.log("Signal dome created at height:", height, "with radius:", radius);
    }
    
    
    
    async function placeTowers(distance, signalRadius) {
        const centerLat = 56.015;
        const centerLng = 92.857;
        const towers = [];  // Массив для хранения данных о башнях
        window.towers = towers;
        const feature = {
            type: "Point",
            coordinates: [centerLng, centerLat],
            properties: {
                level: 0,
                levelHeight: 0,
                base_height: 0,
                min_height: 0,
                height: 0
            }
        };
    
        const pointObj = new THREE.Object3D();
        const centerHeight = await tb.getObjectHeightOnFloor(feature, pointObj, 0);
    
        await loadTowerModel(centerLat, centerLng, centerHeight);
        createSignalDome(centerLat, centerLng, centerHeight, signalRadius);
    
        window.towers.push({ lat: centerLat, lng: centerLng, height: centerHeight, signalRadius });
    
        const bearingOffsets = [0, 72, 144, 216, 288];
    
        const heightsPromises = bearingOffsets.map(async (angle) => {
            const angleRad = angle * Math.PI / 180;
            const latOffset = Math.sin(angleRad) * (distance / 6371000) * (180 / Math.PI);
            const lngOffset = Math.cos(angleRad) * (distance / 6371000) * (180 / Math.PI) / Math.cos(centerLat * Math.PI / 180);
            const newLat = centerLat + latOffset;
            const newLng = centerLng + lngOffset;
    
            const newFeature = {
                type: "Point",
                coordinates: [newLng, newLat],
                properties: {
                    level: 0,
                    levelHeight: 0,
                    base_height: 0,
                    min_height: 0,
                    height: 0
                }
            };
    
            const towerHeight = await tb.getObjectHeightOnFloor(newFeature, pointObj, 0);
            await loadTowerModel(newLat, newLng, towerHeight);
            createSignalDome(newLat, newLng, towerHeight, signalRadius);
    
            window.towers.push({ lat: newLat, lng: newLng, height: towerHeight, signalRadius });
    
            return { newLat, newLng, towerHeight };
        });
    
        const results = await Promise.all(heightsPromises);
        console.log("Towers placed with heights:", results);
        console.log("All Towers:", window.towers);  // Печатаем массив башен для проверки
    }
    
    placeTowers(20000, 300);
    
    

    map.on('style.load', () => {
        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, mbxContext) {
                tb.update();
            },
            render(gl, matrix) {
                tb.update();
            }
        });
    });

    document.getElementById('addPoint').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('lat').value);
        const lng = parseFloat(document.getElementById('lng').value);
        const alt = parseFloat(document.getElementById('alt').value);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(alt)) {
            points.push({ lat, lng, alt });
            alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

            const marker = new maplibregl.Marker()
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setText('Точка маршрута'))
                .addTo(map);
        } else {
            alert("Пожалуйста, введите валидные координаты.");
        }
    });

    // Функция для построения 3D линии
    function draw3dPath() {
        if (points.length < 2) {
            alert("Добавьте хотя бы две точки для построения пути.");
            return;
        }
        
        tb.world.clear();
        for (let i = 0; i < points.length - 1; i++) {
            const start = points[i];
            const end = points[i + 1];

            const line = tb.line({
                geometry: [
                    [start.lng, start.lat, start.alt],
                    [end.lng, end.lat, end.alt]
                ],
                color: '#dd0000',
                width: 4,
                opacity: 1
            });

            tb.add(line);
            // Draw the vertical line at the end of the segment
            const line_vertical = tb.line({
                geometry: [
                    [start.lng, start.lat, start.alt],
                    [start.lng, start.lat, 0]
                ],
                color: '#dd0000',
                width: 1,
                opacity: 1
            })
            tb.add(line_vertical);
        }

        const line_vertical = tb.line({
            geometry: [
                [points[points.length - 1].lng, points[points.length - 1].lat, points[points.length - 1].alt],
                [points[points.length - 1].lng, points[points.length - 1].lat, 0]
            ],
            color: '#dd0000',
            width: 1,
            opacity: 1
        })
        tb.add(line_vertical);


        tb.update();
        alert("3D путь построен!");
        document.getElementById('startFlight').style.display = 'inline-block';
        placeTowers(20000, 300);
    }

    // Построение пути
    document.getElementById('drawPath').addEventListener('click', draw3dPath);

    document.getElementById('startFlight').addEventListener('click', () => {
        if (points.length < 2) {
            alert("Добавьте точки маршрута.");
            return;
        }
    
        // Загрузка модели самолета
        const options = {
            obj: 'http://localhost:9000/scene.glb', // Укажите путь к модели GLB
            type: 'gltf',
            scale: 0.1,
            units: 'meters',
            rotation: { x: 0, y: 0, z: 0 }, // Поворот модели по умолчанию
            anchor: 'center'
        };
    
        window.tb.loadObj(options, function (model) {
            planeModel = model;
            planeModel.setCoords([points[0].lng, points[0].lat, points[0].alt]);
            window.tb.add(planeModel);
            window.tb.update();
            
            // Расчет общей дистанции маршрута
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += calculateDistance(
                    points[i].lat, points[i].lng,
                    points[i + 1].lat, points[i + 1].lng
                );
            }
    
            // Переводим скорость из км/ч в м/с (1 км/ч = 1/3.6 м/с)
            const flightSpeed = 1000 / 3.6;  // скорость в м/с
    
            // Общая длительность полета в миллисекундах
            const duration = totalDistance / flightSpeed * 1000;
    
            let startTime = performance.now();  // Начало анимации
            let previousTime = startTime;
            let progress = 0;
            let currentSegment = 0;
    
            // Функция для интерполяции между двумя точками
            function interpolate(p1, p2, progress) {
                return {
                    lat: p1.lat + (p2.lat - p1.lat) * progress,
                    lng: p1.lng + (p2.lng - p1.lng) * progress,
                    alt: p1.alt + (p2.alt - p1.alt) * progress,
                };
            }

            // Функция для расчета уровня сигнала по логарифмической шкале
            function calculateSignalStrength(distance, signalRadius, minDb = -120, maxDb = 0) {
                // Проверка, если расстояние больше или равно пороговому значению
                if (distance >= signalRadius * 10 * 2.17) {
                    return minDb; // Если дистанция больше или равна максимальному радиусу, возвращаем минимальный уровень сигнала
                }

                // Масштабирование от minDb до maxDb
                const maxDistance = signalRadius * 10 * 2.17;
                const signalDb = maxDb - (maxDb - minDb) * (distance / maxDistance); // Линейная интерполяция

                return Math.max(minDb, Math.min(maxDb, signalDb)); // Ограничиваем значения от minDb до maxDb
            }


            // Функция для расчета уровня шума
            function calculateNoiseLevel(signalStrength,minDb = -120) {
                return minDb - signalStrength ;  // Уровень шума обратно пропорционален уровню сигнала
            }
            // Функция для обновления секундомера и уровня сигнала
            function updateSignalInfo(lat, lng, altitude) {
                let signalStrength = -Infinity;
                let noiseLevel = 0;
                for (const tower of window.towers) {
                    // Вычисляем горизонтальное расстояние
                    const horizontalDistance = calculateDistance(lat, lng, tower.lat, tower.lng);
                    // Вычисляем полное 3D расстояние с учетом высоты
                    const verticalDistance = altitude - tower.height;
                    const totalDistance = Math.sqrt(horizontalDistance * horizontalDistance + verticalDistance * verticalDistance);
                    
                    // Получаем уровень сигнала
                    signalStrength = Math.max(signalStrength, calculateSignalStrength(totalDistance, tower.signalRadius));

                    // Получаем уровень шума
                    noiseLevel = calculateNoiseLevel(signalStrength);
                }

                // Отображаем значения на странице
                document.getElementById('signalStrength').textContent = `Уровень сигнала: ${signalStrength.toFixed(2)} дБ`;
                document.getElementById('noiseLevel').textContent = `Уровень шума: ${noiseLevel.toFixed(2)} дБ`;
            }

    
            let isInsideSignal = false;  // Флаг, показывающий, находится ли самолет внутри сферы
            let timeInsideSignal = 0;  // Время внутри сигнала в секундах
            let signalTimer = null;  // Таймер

            // Функция для проверки, находится ли точка внутри полусферы с учетом высоты
            function isInsideSignalDome(lat, lng, altitude) {
                for (const tower of window.towers) {
                    // Расстояние по горизонтали (поверхность Земли)
                    const horizontalDistance = calculateDistance(lat, lng, tower.lat, tower.lng);
                    
                    // Разница в высоте
                    const verticalDistance = altitude - tower.height;

                    // Полное трехмерное расстояние с учетом горизонтального и вертикального расстояний
                    const distance = Math.sqrt(Math.pow(horizontalDistance, 2) + Math.pow(verticalDistance, 2));

                    //console.log(`Horizontal Distance: ${horizontalDistance}, Vertical Distance: ${verticalDistance}, Total Distance: ${distance}`);
                    
                    // Проверяем, если расстояние меньше или равно радиусу сигнала
                    if (distance <= tower.signalRadius * 10 * 2.17 ) {
                        //console.log("inside sphere!!!");
                        return true;  // Если самолет находится внутри хотя бы одной сферы
                    }
                }
                return false;  // Если самолет вне всех сфер
            }


            // Функция для обновления секундомера
            function updateTimer() {
                const timerElement = document.getElementById('timer');
                if (isInsideSignal) {
                    timeInsideSignal += 0.1;  // Увеличиваем время на 0.1 секунды (каждую десятую долю)
                    timerElement.textContent = timeInsideSignal.toFixed(2);  // Отображаем время с точностью до сотых
                }
            }

            let followCamera = false;  // Переменная для отслеживания режима следования камеры

            // Обработчик кнопки переключения следования камеры
            document.getElementById('toggleCameraFollow').addEventListener('click', () => {
                followCamera = !followCamera;  // Переключаем режим
                const buttonText = followCamera ? 'Не следовать за самолетом' : 'Следовать за самолетом';
                document.getElementById('toggleCameraFollow').textContent = buttonText;
            });

            // Параметры смещения камеры относительно самолета
            const cameraOffset = {
                x: 0.01,   // Камера будет на том же уровне по оси X
                y: 0.001,   // Камера будет на том же уровне по оси Y
                z: -0.001  // Камера будет на хвосте самолета (отрицательное значение по оси Z)
            };

            // Обновленная анимация полета
            function animate() {
                const currentTime = performance.now();
                const elapsedTime = currentTime - startTime;
                progress = Math.min(elapsedTime / duration, 1);

                // Находим текущий сегмент пути
                let segmentProgress = (elapsedTime / duration) * (points.length - 1);
                currentSegment = Math.floor(segmentProgress);
                let nextSegment = currentSegment + 1;

                if (nextSegment >= points.length) {
                    nextSegment = points.length - 1;
                }

                let p1 = points[currentSegment];
                let p2 = points[nextSegment];

                const segmentProgressNormalized = segmentProgress - currentSegment;
                const pos = interpolate(p1, p2, segmentProgressNormalized);
                planeModel.setCoords([pos.lng, pos.lat, pos.alt]);

                // Вычисляем угол поворота самолета
                const angle = calculateAngle(p1, p2);  // Угол направления движения самолета

                // Если включен режим следования камеры
                if (followCamera) {
                    // Камера будет следовать за самолетом, добавляем смещение по оси Z
                    const cameraLng = pos.lng + cameraOffset.x;   // Смещение камеры по долготе
                    const cameraLat = pos.lat + cameraOffset.y;   // Смещение камеры по широте
                    const cameraAltitude = pos.alt + cameraOffset.z;  // Смещение камеры по высоте

                    // Поворот камеры на 180 градусов относительно самолета (чтобы камера была сзади)
                    const adjustedBearing = angle + 90 ;  // Поворот камеры в противоположную сторону

                    map.jumpTo({
                        center: [cameraLng, cameraLat],
                        zoom: 15.0, //14.4
                        pitch: 55,  // Угол наклона камеры
                        bearing: adjustedBearing,  // Поворот камеры в направлении хвоста
                    });
                }

                // Проверка на нахождение внутри сигнала
                const insideSignal = isInsideSignalDome(pos.lat, pos.lng, pos.alt);

                // Если самолет входит в радиус сигнала и еще не был внутри, запускаем таймер
                if (insideSignal && !isInsideSignal) {
                    isInsideSignal = true;
                    signalTimer = setInterval(updateTimer, 100);  // Запускаем таймер (обновляем каждую десятую долю)
                }

                // Если самолет выходит из радиуса сигнала и был внутри, останавливаем таймер
                if (!insideSignal && isInsideSignal) {
                    isInsideSignal = false;
                    clearInterval(signalTimer);  // Останавливаем таймер
                }

                // Поворот и другие действия с самолетом
                const tilt = calculateTilt(p1, p2);
                planeModel.setRotation({ x: 90, y: angle * (180 / Math.PI), z: tilt * (180 / Math.PI) });

                window.tb.update();

                // Обновляем общее время полета
                const totalFlightTime = (elapsedTime / 1000).toFixed(2);  // Время в секундах
                document.getElementById('flightTime').textContent = `Общее время полета: ${totalFlightTime}s`;

                // Обновляем процент времени в сигнале
                const signalTimePercentage = (timeInsideSignal / totalFlightTime * 100).toFixed(2);
                document.getElementById('signalPercentage').textContent = `Процент времени в сигнале: ${signalTimePercentage}%`;
                // В функции animate, добавляем вызов обновления сигнала
                updateSignalInfo(pos.lat, pos.lng, pos.alt);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    alert("Полет завершен!");
                    clearInterval(signalTimer);  // Останавливаем таймер по завершению полета
                }
            }


    
            // Запуск анимации
            animate();
        });
    });
    
    // Функция для вычисления угла наклона по оси Z (по высоте)
    function calculateTilt(p1, p2) {
        const horizontalDistance = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng); // Горизонтальное расстояние между точками
        const heightDifference = p2.alt - p1.alt; // Разница по высоте
        return -1 * Math.atan2(heightDifference, horizontalDistance); // Угол наклона
    }
    
    // Функция для вычисления расстояния между двумя точками на поверхности Земли
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Радиус Земли в км
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c * 1000;  // Расстояние в метрах
    }
    
    // Функция для вычисления угла между двумя точками
    function calculateAngle(p1, p2) {
        const dx = p2.lng - p1.lng;
        const dy = p2.lat - p1.lat;
        return Math.atan2(dy, dx); // Возвращаем угол в радианах
    }
    

</script>
</body>
</html>

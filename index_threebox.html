<!--
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Krasnoyarsk Krai 3D Terrain with Model</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
    <script src="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.min.js" type="text/javascript"></script>
    <link href="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script type="module">
    console.log("Here");
    const krasnoyarskBounds = [
        [90.0, 53.0], // Southwest coordinates [lng, lat]
        [96.0, 60.0]  // Northeast coordinates [lng, lat]
    ];

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 6,
        center: [92.857, 56.015], // Center coordinates for Krasnoyarsk Krai
        pitch: 70,
        bearing: 0,
        antialias: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                terrainSource: {
                    type: 'raster-dem',
                    tiles: [
                        'https://tiles.wifidb.net/data/jaxa_terrainrgb/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1.5
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85,
        maxBounds: krasnoyarskBounds // Restrict map to Krasnoyarsk Krai
    });

    map.addControl(new maplibregl.NavigationControl({
        visualizePitch: true,
        showZoom: true,
        showCompass: true
    }));

    // // Создание маркера
    // const marker = new maplibregl.Marker()
    //     .setLngLat([92.857, 56.015]) // Координаты маркера
    //     .setPopup(new maplibregl.Popup().setText('Здесь должна быть модель самолета')) // Подсказка
    //     .addTo(map); // Добавление маркера на карту
    
    const tb = (window.tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    ));

    map.on('style.load', () => {


        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd: function (map, mbxContext) {
                var options = {
                    obj: 'http://localhost:9000/scene.glb',
                    type: 'gltf',
                    scale: 1,
                    units: 'meters',
                    rotation: { x: 90, y: 0, z: 0 }, //default rotation
                    anchor: 'center'
                }

                tb.loadObj(options, function (model) {
                    console.log("Here 2");
                    let plane = model.setCoords([92.857, 56.015]);
                    //plane.setAltitude(100); // Увеличьте значение, чтобы поднять модель выше
                    tb.add(plane);
                    console.log(plane);
                }, function (error) {
                    console.error('Error loading model:', error);
                });

            },

            render: function (gl, matrix) {
                tb.update();
            }
        });
    });
    /*
    map.on('error', (e) => {
        console.error('Map error:', e);
    });*/
</script>
</body>
</html>
-->



<!--
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Krasnoyarsk Krai 3D Terrain with Model</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.min.js" type="text/javascript"></script>
    <link href="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #controls { position: absolute; top: 10px; left: 10px; background: white; padding: 10px; z-index: 1; }
        .marker {
            background-color: red;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="controls">
    <h3>Введите координаты</h3>
    <input type="text" id="lat" placeholder="Широта">
    <input type="text" id="lng" placeholder="Долгота">
    <input type="text" id="alt" placeholder="Высота">
    <button id="addPoint">Добавить точку</button>
    <button id="drawPath">Построить путь</button>
</div>
<div id="map"></div>
<script type="module">
    const krasnoyarskBounds = [
        [90.0, 53.0], // Southwest coordinates [lng, lat]
        [96.0, 60.0]  // Northeast coordinates [lng, lat]
    ];

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 6,
        center: [92.857, 56.015], // Center coordinates for Krasnoyarsk Krai
        pitch: 70,
        bearing: 0,
        antialias: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                terrainSource: {
                    type: 'raster-dem',
                    tiles: [
                        'https://tiles.wifidb.net/data/jaxa_terrainrgb/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1.5
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85,
        maxBounds: krasnoyarskBounds // Restrict map to Krasnoyarsk Krai
    });

    const tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    );

    const points = [];

    map.on('style.load', () => {
        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, mbxContext) {
                tb.update();
            },
            render(gl, matrix) {
                tb.update();
            }
        });
    });

    document.getElementById('addPoint').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('lat').value);
        const lng = parseFloat(document.getElementById('lng').value);
        const alt = parseFloat(document.getElementById('alt').value);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(alt)) {
            points.push({ lat, lng, alt });
            alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

        const marker = new maplibregl.Marker()
        .setLngLat([lng, lat]) // Координаты маркера
        .setPopup(new maplibregl.Popup().setText('Здесь должна быть модель самолета')) // Подсказка
        .addTo(map); // Добавление маркера на карту

        } else {
            alert("Пожалуйста, введите валидные координаты.");
        }
    });

    function createLine(start, end) {
    const positions = new Float32Array(6); // 2 vertices * 3 coordinates (x, y, z)

    // Project the geographical coordinates to world coordinates
    const startWorld = tb.projectToWorld(start);
    const endWorld = tb.projectToWorld(end);

    // Set the positions for the line
    positions[0] = startWorld.x; // x of start
    positions[1] = startWorld.y; // y of start
    positions[2] = startWorld.z; // z of start
    positions[3] = endWorld.x;   // x of end
    positions[4] = endWorld.y;   // y of end
    positions[5] = endWorld.z;   // z of end

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    return new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
}

    document.getElementById('drawPath').addEventListener('click', () => {
        if (points.length < 2) {
            alert("Добавьте хотя бы две точки для построения пути.");
            return;
        }

        // Create lines between each pair of points
        for (let i = 0; i < points.length - 1; i++) {
            const startPoint = points[i];
            const endPoint = points[i + 1];

            // Create a line using the createLine function
            const lineMesh = createLine(
                [startPoint.lng, startPoint.lat], // Start point as [lng, lat]
                [endPoint.lng, endPoint.lat]      // End point as [lng, lat]
            );

            // Add the line mesh to Threebox world
            tb.world.add(lineMesh);
        }

        tb.update(); // Force the map to render

        alert("Путь построен!");
    });
</script>
</body>
</html>

-->
<!--
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Krasnoyarsk Krai 3D Terrain with Model</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.min.js" type="text/javascript"></script>
    <link href="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #controls { position: absolute; top: 10px; left: 10px; background: white; padding: 10px; z-index: 1; }
        .marker {
            background-color: red;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="controls">
    <h3>Введите координаты</h3>
    <input type="text" id="lat" placeholder="Широта">
    <input type="text" id="lng" placeholder="Долгота">
    <input type="text" id="alt" placeholder="Высота">
    <button id="addPoint">Добавить точку</button>
    <button id="drawPath">Построить путь</button>
    <button id="startFlight" style="display:none;">Начать полет</button>
</div>
<div id="map"></div>
<script type="module">
    const krasnoyarskBounds = [
        [90.0, 53.0], // Southwest coordinates [lng, lat]
        [96.0, 60.0]  // Northeast coordinates [lng, lat]
    ];

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 6,
        center: [92.857, 56.015], // Center coordinates for Krasnoyarsk Krai
        pitch: 70,
        bearing: 0,
        antialias: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                terrainSource: {
                    type: 'raster-dem',
                    tiles: [
                        'https://tiles.wifidb.net/data/jaxa_terrainrgb/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1.5
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85,
        maxBounds: krasnoyarskBounds // Restrict map to Krasnoyarsk Krai
    });

    const tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    );
    window.tb = tb;
    const points = [];  // Массив для хранения точек маршрута
    let planeModel = null;
    let currentPointIndex = 0;  // Индекс текущей точки маршрута
    let totalDistance = 0;  // Общая дистанция маршрута

    map.on('style.load', () => {
        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, mbxContext) {
                tb.update();
            },
            render(gl, matrix) {
                tb.update();
            }
        });
    });

    document.getElementById('addPoint').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('lat').value);
        const lng = parseFloat(document.getElementById('lng').value);
        const alt = parseFloat(document.getElementById('alt').value);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(alt)) {
            points.push({ lat, lng, alt });
            alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

            const marker = new maplibregl.Marker()
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setText('Точка маршрута'))
                .addTo(map);
        } else {
            alert("Пожалуйста, введите валидные координаты.");
        }
    });



    // Создание пути между точками
    function createLine(start, end) {
        const positions = new Float32Array(6); // 2 vertices * 3 coordinates (x, y, z)

        // Project the geographical coordinates to world coordinates
        const startWorld = tb.projectToWorld(start);
        const endWorld = tb.projectToWorld(end);

        // Set the positions for the line
        positions[0] = startWorld.x; // x of start
        positions[1] = startWorld.y; // y of start
        positions[2] = startWorld.z; // z of start
        positions[3] = endWorld.x;   // x of end
        positions[4] = endWorld.y;   // y of end
        positions[5] = endWorld.z;   // z of end

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        return new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
    }

    // Построение пути
    document.getElementById('drawPath').addEventListener('click', () => {
        if (points.length < 2) {
            alert("Добавьте хотя бы две точки для построения пути.");
            return;
        }

        // Create lines between each pair of points
        for (let i = 0; i < points.length - 1; i++) {
            const startPoint = points[i];
            const endPoint = points[i + 1];

            // Create a line using the createLine function
            const lineMesh = createLine(
                [startPoint.lng, startPoint.lat], // Start point as [lng, lat]
                [endPoint.lng, endPoint.lat]      // End point as [lng, lat]
            );

            // Add the line mesh to Threebox world
            tb.world.add(lineMesh);

            // Calculate total distance of the path
            totalDistance += calculateDistance(startPoint.lat, startPoint.lng, endPoint.lat, endPoint.lng);
        }

        tb.update(); // Force the map to render

        alert("Путь построен!");
        document.getElementById('startFlight').style.display = 'inline-block';
    });

    // Начало полета
    document.getElementById('startFlight').addEventListener('click', () => {
        if (points.length < 2) {
            alert("Добавьте точки маршрута.");
            return;
        }

        // Загрузка модели самолета
        const options = {
            obj: 'http://localhost:9000/scene.glb', // Укажите путь к модели GLB
            type: 'gltf',
            scale: 0.3,
            units: 'meters',
            rotation: { x: 90, y: 0, z: 0 },
            anchor: 'center'
        };

        window.tb.loadObj(options, function (model) {
            planeModel = model;
            planeModel.setCoords([points[0].lng, points[0].lat, points[0].alt]);
            window.tb.add(planeModel);
            window.tb.update();

            // Расчет общей дистанции маршрута
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += calculateDistance(
                    points[i].lat, points[i].lng,
                    points[i + 1].lat, points[i + 1].lng
                );
            }

            // Переводим скорость из км/ч в м/с (1 км/ч = 1/3.6 м/с)
            const flightSpeed = 50 / 3.6;  // скорость в м/с

            // Начинаем анимацию
            let currentTime = 0;  // Текущее время анимации (в миллисекундах)
            const duration = totalDistance / flightSpeed * 1000; // Общая длительность полета в миллисекундах
            const path = points.map(p => [p.lng, p.lat, p.alt]);

            function animate() {
                currentTime += 1000 / 60; // Обновление каждую миллисекунду
                const t = currentTime / duration; // Прогресс (от 0 до 1)

                if (t < 1) {
                    // Находим две точки для интерполяции
                    const startIndex = Math.floor(t * (points.length - 1));
                    const endIndex = startIndex + 1;
                    const p1 = points[startIndex];
                    const p2 = points[endIndex];

                    // Интерполяция между точками маршрута
                    const interpolate = (p1, p2, t) => {
                        return {
                            lat: p1.lat + (p2.lat - p1.lat) * t,
                            lng: p1.lng + (p2.lng - p1.lng) * t,
                            alt: p1.alt + (p2.alt - p1.alt) * t,
                        };
                    };

                    const pos = interpolate(p1, p2, (t * (points.length - 1)) % 1);
                    planeModel.setCoords([pos.lng, pos.lat, pos.alt]);

                    window.tb.update();
                    requestAnimationFrame(animate); // Продолжаем анимацию
                } else {
                    alert("Полет завершен!");
                }
            }

            animate(); // Запуск анимации
        });
    });

    // Функция для вычисления дистанции между двумя точками на поверхности Земли
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Радиус Земли в км
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c * 1000;  // Расстояние в метрах
    }

</script>
</body>
</html>


-->

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Krasnoyarsk Krai 3D Terrain with Model</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.min.js" type="text/javascript"></script>
    <link href="https://unpkg.com/threebox-plugin@2.2.1/dist/threebox.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            z-index: 1;
        }
        .marker {
            background-color: red;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        #toggle2D {
            position: absolute;
            top: 10.8%; /* Позиция под стандартными контролами */
            z-index: 2;
            margin-left: 97.7%;
            background-color: #ffffff;
            border: 1px solid #ccc;
            cursor: pointer;
        }
    </style>
</head>
<body>
<button id="toggle2D" style="display: block; margin-top: 10px;">2D</button>
<div id="controls">
    <h3>Введите координаты</h3>
    <input type="text" id="lat" placeholder="Широта">
    <input type="text" id="lng" placeholder="Долгота">
    <input type="text" id="alt" placeholder="Высота">
    <button id="addPoint">Добавить точку</button>
    <button id="drawPath">Построить путь</button>
    <button id="startFlight" style="display:none;">Начать полет</button>
    
    <h3>Время действия сигнала (sec)</h3>
    <div id="timer">0</div> <!-- Секундомер -->
</div>
<div id="map"></div>
<script type="module">
    const krasnoyarskBounds = [
        [90.0, 53.0], // Southwest coordinates [lng, lat]
        [96.0, 60.0]  // Northeast coordinates [lng, lat]
    ];

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 6,
        center: [92.857, 56.015], // Center coordinates for Krasnoyarsk Krai
        pitch: 70,
        bearing: 0,
        antialias: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                terrainSource: {
                    type: 'raster-dem',
                    tiles: [
                        'https://tiles.wifidb.net/data/jaxa_terrainrgb/{z}/{x}/{y}.png'
                    ],
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1.5
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85,
        maxBounds: krasnoyarskBounds // Restrict map to Krasnoyarsk Krai
    });

    map.addControl(new maplibregl.NavigationControl({
        visualizePitch: true,
        showZoom: true,
        showCompass: true
    }));
    
    document.getElementById('toggle2D').addEventListener('click', () => {
        const currentPitch = map.getPitch();
    
        if (currentPitch > 0) {
            // Переключаем на 2D (вид сверху)
            map.setPitch(0);  // Убираем наклон
            map.setBearing(0);  // Убираем вращение
            map.setZoom(6);  // Устанавливаем обычный масштаб
            document.getElementById('toggle2D').textContent = '3D';
        } else {
            // Переключаем на 3D
            map.setPitch(70);  // Устанавливаем наклон для 3D
            map.setBearing(0);  // Устанавливаем нормальное направление
            map.setZoom(6);  // Масштаб для 3D
            document.getElementById('toggle2D').textContent = '2D';
        }
    });
    

    
    const tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    );
    window.tb = tb;
    const points = [];  // Массив для хранения точек маршрута
    let planeModel = null;  // Модель самолета
    let currentPointIndex = 0;  // Индекс текущей точки маршрута

    function loadTowerModel(lat, lng, alt) {
        const towerModelUrl = 'http://localhost:9000/tower.glb'; // Укажите правильный путь к вашему файлу GLB
        const options = {
            obj: towerModelUrl,
            type: 'gltf',
            scale: 1000,
            units: 'meters',
            rotation: { x: 90, y: 0, z: 0 },
            anchor: 'center'
        };
    
        window.tb.loadObj(options, function (model) {
            model.setCoords([lng, lat, alt]); // Устанавливаем координаты с высотой рельефа
            window.tb.add(model);
            window.tb.update();
            console.log("Model loaded at height:", alt);
        });
    }
    
    

    // Изменение проверки на пересечение с полусферой (исправленный радиус)
    function createSignalDome(lat, lng, height, radius) {
        // Создаем полусферу с помощью Threebox
        const dome = window.tb.sphere({
            color: 'blue',  // Зеленый цвет
            material: 'MeshBasicMaterial', // Простой материал
            transparent: true,  // Сделать полусферу прозрачной
            opacity: 0.3,  // Устанавливаем прозрачность
            side: THREE.DoubleSide, // Покажем обе стороны
            radius: radius,
            units: 'meter',
            phiLength: Math.PI,  // Ограничиваем угол phi до 180 градусов (полусфера)
            anchor: 'center',  // Центрируем сферу по координатам
            adjustment: { x: 0, y: 0, z: -0.5 }  // Сдвиг на 0, чтобы центр совпал с координатами
        })
        .setCoords([lng, lat, height + radius]);  // Устанавливаем координаты
        window.tb.add(dome);
        window.tb.update();
        console.log("Signal dome created at height:", height, "with radius:", radius);
    }
    
    
    
    async function placeTowers(distance, signalRadius) {
        const centerLat = 56.015;
        const centerLng = 92.857;
        const towers = [];  // Массив для хранения данных о башнях
        window.towers = towers;
        const feature = {
            type: "Point",
            coordinates: [centerLng, centerLat],
            properties: {
                level: 0,
                levelHeight: 0,
                base_height: 0,
                min_height: 0,
                height: 0
            }
        };
    
        const pointObj = new THREE.Object3D();
        const centerHeight = await tb.getObjectHeightOnFloor(feature, pointObj, 0);
    
        await loadTowerModel(centerLat, centerLng, centerHeight);
        createSignalDome(centerLat, centerLng, centerHeight, signalRadius);
    
        window.towers.push({ lat: centerLat, lng: centerLng, height: centerHeight, signalRadius });
    
        const bearingOffsets = [0, 72, 144, 216, 288];
    
        const heightsPromises = bearingOffsets.map(async (angle) => {
            const angleRad = angle * Math.PI / 180;
            const latOffset = Math.sin(angleRad) * (distance / 6371000) * (180 / Math.PI);
            const lngOffset = Math.cos(angleRad) * (distance / 6371000) * (180 / Math.PI) / Math.cos(centerLat * Math.PI / 180);
            const newLat = centerLat + latOffset;
            const newLng = centerLng + lngOffset;
    
            const newFeature = {
                type: "Point",
                coordinates: [newLng, newLat],
                properties: {
                    level: 0,
                    levelHeight: 0,
                    base_height: 0,
                    min_height: 0,
                    height: 0
                }
            };
    
            const towerHeight = await tb.getObjectHeightOnFloor(newFeature, pointObj, 0);
            await loadTowerModel(newLat, newLng, towerHeight);
            createSignalDome(newLat, newLng, towerHeight, signalRadius);
    
            window.towers.push({ lat: newLat, lng: newLng, height: towerHeight, signalRadius });
    
            return { newLat, newLng, towerHeight };
        });
    
        const results = await Promise.all(heightsPromises);
        console.log("Towers placed with heights:", results);
        console.log("All Towers:", window.towers);  // Печатаем массив башен для проверки
    }
    
    placeTowers(20000, 300);
    
    

    map.on('style.load', () => {
        map.addLayer({
            id: 'custom_layer',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, mbxContext) {
                tb.update();
            },
            render(gl, matrix) {
                tb.update();
            }
        });
    });

    document.getElementById('addPoint').addEventListener('click', () => {
        const lat = parseFloat(document.getElementById('lat').value);
        const lng = parseFloat(document.getElementById('lng').value);
        const alt = parseFloat(document.getElementById('alt').value);

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(alt)) {
            points.push({ lat, lng, alt });
            alert(`Точка добавлена: [${lat}, ${lng}, ${alt}]`);

            const marker = new maplibregl.Marker()
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setText('Точка маршрута'))
                .addTo(map);
        } else {
            alert("Пожалуйста, введите валидные координаты.");
        }
    });

    // Функция для построения 3D линии
    function draw3dPath() {
        if (points.length < 2) {
            alert("Добавьте хотя бы две точки для построения пути.");
            return;
        }
        
        tb.world.clear();
        for (let i = 0; i < points.length - 1; i++) {
            const start = points[i];
            const end = points[i + 1];

            const line = tb.line({
                geometry: [
                    [start.lng, start.lat, start.alt],
                    [end.lng, end.lat, end.alt]
                ],
                color: '#dd0000',
                width: 4,
                opacity: 1
            });

            tb.add(line);
            // Draw the vertical line at the end of the segment
            const line_vertical = tb.line({
                geometry: [
                    [start.lng, start.lat, start.alt],
                    [start.lng, start.lat, 0]
                ],
                color: '#dd0000',
                width: 1,
                opacity: 1
            })
            tb.add(line_vertical);
        }

        const line_vertical = tb.line({
            geometry: [
                [points[points.length - 1].lng, points[points.length - 1].lat, points[points.length - 1].alt],
                [points[points.length - 1].lng, points[points.length - 1].lat, 0]
            ],
            color: '#dd0000',
            width: 1,
            opacity: 1
        })
        tb.add(line_vertical);


        tb.update();
        alert("3D путь построен!");
        document.getElementById('startFlight').style.display = 'inline-block';
        placeTowers(20000, 300);
    }

    // Построение пути
    document.getElementById('drawPath').addEventListener('click', draw3dPath);

    document.getElementById('startFlight').addEventListener('click', () => {
        if (points.length < 2) {
            alert("Добавьте точки маршрута.");
            return;
        }
    
        // Загрузка модели самолета
        const options = {
            obj: 'http://localhost:9000/scene.glb', // Укажите путь к модели GLB
            type: 'gltf',
            scale: 0.3,
            units: 'meters',
            rotation: { x: 0, y: 0, z: 0 }, // Поворот модели по умолчанию
            anchor: 'center'
        };
    
        window.tb.loadObj(options, function (model) {
            planeModel = model;
            planeModel.setCoords([points[0].lng, points[0].lat, points[0].alt]);
            window.tb.add(planeModel);
            window.tb.update();
            
            // Расчет общей дистанции маршрута
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += calculateDistance(
                    points[i].lat, points[i].lng,
                    points[i + 1].lat, points[i + 1].lng
                );
            }
    
            // Переводим скорость из км/ч в м/с (1 км/ч = 1/3.6 м/с)
            const flightSpeed = 1000 / 3.6;  // скорость в м/с
    
            // Общая длительность полета в миллисекундах
            const duration = totalDistance / flightSpeed * 1000;
    
            let startTime = performance.now();  // Начало анимации
            let previousTime = startTime;
            let progress = 0;
            let currentSegment = 0;
    
            // Функция для интерполяции между двумя точками
            function interpolate(p1, p2, progress) {
                return {
                    lat: p1.lat + (p2.lat - p1.lat) * progress,
                    lng: p1.lng + (p2.lng - p1.lng) * progress,
                    alt: p1.alt + (p2.alt - p1.alt) * progress,
                };
            }
    
            let isInsideSignal = false;  // Флаг, показывающий, находится ли самолет внутри сферы
            let timeInsideSignal = 0;  // Время внутри сигнала в секундах
            let signalTimer = null;  // Таймер

            // Функция для проверки, находится ли точка внутри полусферы с учетом высоты
            function isInsideSignalDome(lat, lng, altitude) {
                for (const tower of window.towers) {
                    // Расстояние по горизонтали (поверхность Земли)
                    const horizontalDistance = calculateDistance(lat, lng, tower.lat, tower.lng);
                    
                    // Разница в высоте
                    const verticalDistance = altitude - tower.height;

                    // Полное трехмерное расстояние с учетом горизонтального и вертикального расстояний
                    const distance = Math.sqrt(Math.pow(horizontalDistance, 2) + Math.pow(verticalDistance, 2));

                    console.log(`Horizontal Distance: ${horizontalDistance}, Vertical Distance: ${verticalDistance}, Total Distance: ${distance}`);
                    
                    // Проверяем, если расстояние меньше или равно радиусу сигнала
                    if (distance <= tower.signalRadius * 10 * 2.17 ) {
                        console.log("inside sphere!!!");
                        return true;  // Если самолет находится внутри хотя бы одной сферы
                    }
                }
                return false;  // Если самолет вне всех сфер
            }


            // Функция для обновления секундомера
            function updateTimer() {
                const timerElement = document.getElementById('timer');
                if (isInsideSignal) {
                    timeInsideSignal += 0.1;  // Увеличиваем время на 0.1 секунды (каждую десятую долю)
                    timerElement.textContent = timeInsideSignal.toFixed(2);  // Отображаем время с точностью до сотых
                }
            }

            // Анимация полета
            function animate() {
                const currentTime = performance.now();
                const elapsedTime = currentTime - startTime;
                progress = Math.min(elapsedTime / duration, 1);

                // Находим текущий сегмент
                let segmentProgress = (elapsedTime / duration) * (points.length - 1);
                currentSegment = Math.floor(segmentProgress);
                let nextSegment = currentSegment + 1;

                if (nextSegment >= points.length) {
                    nextSegment = points.length - 1;
                }

                let p1 = points[currentSegment];
                let p2 = points[nextSegment];

                const segmentProgressNormalized = segmentProgress - currentSegment;
                const pos = interpolate(p1, p2, segmentProgressNormalized);
                planeModel.setCoords([pos.lng, pos.lat, pos.alt]);

                // Проверяем, находится ли самолет внутри сферы
                const insideSignal = isInsideSignalDome(pos.lat, pos.lng, pos.alt);

                // Если самолет входит в радиус сигнала и еще не был внутри, запускаем таймер
                if (insideSignal && !isInsideSignal) {
                    isInsideSignal = true;
                    //timeInsideSignal = 0;  // Сбрасываем время, когда самолет входит в радиус
                    signalTimer = setInterval(updateTimer, 100);  // Запускаем таймер (обновляем каждую секунду)
                }

                // Если самолет выходит из радиуса сигнала и был внутри, останавливаем таймер
                if (!insideSignal && isInsideSignal) {
                    isInsideSignal = false;
                    clearInterval(signalTimer);  // Останавливаем таймер
                }

                // Поворот и другие действия с самолетом
                const angle = calculateAngle(p1, p2);
                const tilt = calculateTilt(p1, p2);
                planeModel.setRotation({ x: 90, y: angle * (180 / Math.PI), z: tilt * (180 / Math.PI) });

                window.tb.update();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    alert("Полет завершен!");
                    clearInterval(signalTimer);  // Останавливаем таймер по завершению полета
                }
            }
    
            // Запуск анимации
            animate();
        });
    });
    
    // Функция для вычисления угла наклона по оси Z (по высоте)
    function calculateTilt(p1, p2) {
        const horizontalDistance = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng); // Горизонтальное расстояние между точками
        const heightDifference = p2.alt - p1.alt; // Разница по высоте
        return -1 * Math.atan2(heightDifference, horizontalDistance); // Угол наклона
    }
    
    // Функция для вычисления расстояния между двумя точками на поверхности Земли
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Радиус Земли в км
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c * 1000;  // Расстояние в метрах
    }
    
    // Функция для вычисления угла между двумя точками
    function calculateAngle(p1, p2) {
        const dx = p2.lng - p1.lng;
        const dy = p2.lat - p1.lat;
        return Math.atan2(dy, dx); // Возвращаем угол в радианах
    }
    

</script>
</body>
</html>
